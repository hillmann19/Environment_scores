library(tidycensus)
library(tidygeocoder)
library(tidyverse)
library(tigris)
library(parallel)
?get_acs
runGeocodeArcGIS <- function(df,address_col){
newdf <- geo(address = df[,address_col],method = "arcgis")
newdf$year <- str_replace_all(df$DOVISIT,pattern = "-.*",replacement = "")
return(newdf)
}
# Read in the data and packages
library(tidycensus)
library(tidygeocoder)
library(tidyverse)
library(tigris)
library(parallel)
address <- read_delim("~/Projects/Geocoding/Data/address_dump_oracle_Oct2021.xls",
delim = "\t", escape_double = FALSE,
col_types = cols(...11 = col_skip()),
trim_ws = TRUE)
demo <- read_csv("~/Projects/Geocoding/Data/address_dump_oracle_demographics.csv")
# call_geolocator_laton comes from the tidygeocoder package, had to make changes to the url so it ran properly
call_geolocator_latlon <- function(lat, lon, benchmark, vintage) {
if(missing(benchmark)) {
benchmark<-"Public_AR_Current"
} else {
benchmark<-benchmark
}
if(missing(vintage)) {
vintage<-"Current_Current"
} else {
vintage<-vintage
}
# Build url
call_start <- "https://geocoding.geo.census.gov/geocoder/geographies/coordinates?"
url <- paste0("x=", lon,"&y=", lat)
benchmark0 <- paste0("&benchmark=", benchmark)
vintage0 <- paste0("&vintage=", vintage, "&format=json")
url_full <- paste0(call_start, url, benchmark0, vintage0)
#print(url_full)
# Check response
r <- httr::GET(url_full)
httr::stop_for_status(r)
response <- httr::content(r)
if (length(response$result$geographies$`Census Blocks`[[1]]$GEOID) == 0) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned no geocodes. An NA was returned."))
return(NA_character_)
} else {
#regex search for block group geography in response
response_block<-grep(response[["result"]][["geographies"]], pattern = ".Block.")
#check If a block group result is found or return NA
#If block group response is found check GEOID length and return either NA for missing data or the value
if(length(response_block) == 0){
return(NA_character_)
} else {
if (length(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID) == 0) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned no geocodes. An NA was returned."))
return(NA_character_)
} else {
if (length(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID) > 1) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned more than geocode. The first match was returned."))
}
return(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID)
}
}
}
}
# Function which takes an address data frame and outputs a data frame with the latitude and longitude coordinates for the permanent address
runGeocodeArcGIS <- function(df,address_col){
newdf <- geo(address = df[,address_col],method = "arcgis")
newdf$year <- str_replace_all(df$DOVISIT,pattern = "-.*",replacement = "")
return(newdf)
}
getCensusBlocks <- function(df){
CensusBlock <- call_geolocator_latlon(lat = df$lat, lon = df$long,vintage = "Census2010_Current")
newdf <- data.frame("address" = df$address,lat = df$lat,long = df$long,CensusBlock = CensusBlock,year = df$year)
return(newdf)
}
# Function which takes the state, country, tract, and (partial) block numbers for an address and linnks the block to variables from the ACS survey
getCensusVars <- function(df){
geoID <- paste0(df$state,df$county,df$tract,str_sub(df$block,start = 1,end = 1))
Census <- get_acs(geography = "block group",state = df$state,county = df$county,variables = NewVars,year = min(max(as.numeric(df$year) + 2,2013),2019))
Census.long <- Census %>%
filter(GEOID == geoID) %>%
select(variable,estimate) %>%
pivot_wider(names_from = variable,values_from = estimate)
newdf <- cbind(df,Census.long) %>%
select(-`row_number()`)
return(newdf)
}
address2 <- address %>%
mutate(across(c(PERM_ADDRESS,LOCAL_ADDRESS),~str_remove_all(.x,pattern = ","))) %>% # Remove commas from address
mutate(across(c(PERM_ADDRESS,LOCAL_ADDRESS), ~ str_trim(.x,side = "both"))) %>% #Trim whitespace in addresses
unite("PERM_address_full",PERM_ADDRESS:PERM_ZIP,sep = ", ",remove = FALSE) %>% # Create column for one line permanent address
unite("Local_address_full",LOCAL_ADDRESS:LOCAL_ZIP,sep = ", ",remove = FALSE) # Same thing for local addresses
# Split address2 data frame into list
address.all.list <- address2 %>%
group_split(row_number())
numCores <- detectCores()
parallel::mclapply(address.all.list[[1]],FUN = runGeocodeArcGIS(address = "PERM_address_full"),mc.cores = numCores)
parallel::mclapply(address.all.list[[1]],FUN = runGeocodeArcGIS(address_col = "PERM_address_full"),mc.cores = numCores)
parallel::mclapply(address.all.list[1],FUN = runGeocodeArcGIS(address_col = "PERM_address_full"),mc.cores = numCores)
# Read in the data and packages
library(tidycensus)
library(tidygeocoder)
library(tidyverse)
library(tigris)
library(parallel)
address <- read_delim("~/Projects/Geocoding/Data/address_dump_oracle_Oct2021.xls",
delim = "\t", escape_double = FALSE,
col_types = cols(...11 = col_skip()),
trim_ws = TRUE)
demo <- read_csv("~/Projects/Geocoding/Data/address_dump_oracle_demographics.csv")
# call_geolocator_laton comes from the tidygeocoder package, had to make changes to the url so it ran properly
call_geolocator_latlon <- function(lat, lon, benchmark, vintage) {
if(missing(benchmark)) {
benchmark<-"Public_AR_Current"
} else {
benchmark<-benchmark
}
if(missing(vintage)) {
vintage<-"Current_Current"
} else {
vintage<-vintage
}
# Build url
call_start <- "https://geocoding.geo.census.gov/geocoder/geographies/coordinates?"
url <- paste0("x=", lon,"&y=", lat)
benchmark0 <- paste0("&benchmark=", benchmark)
vintage0 <- paste0("&vintage=", vintage, "&format=json")
url_full <- paste0(call_start, url, benchmark0, vintage0)
#print(url_full)
# Check response
r <- httr::GET(url_full)
httr::stop_for_status(r)
response <- httr::content(r)
if (length(response$result$geographies$`Census Blocks`[[1]]$GEOID) == 0) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned no geocodes. An NA was returned."))
return(NA_character_)
} else {
#regex search for block group geography in response
response_block<-grep(response[["result"]][["geographies"]], pattern = ".Block.")
#check If a block group result is found or return NA
#If block group response is found check GEOID length and return either NA for missing data or the value
if(length(response_block) == 0){
return(NA_character_)
} else {
if (length(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID) == 0) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned no geocodes. An NA was returned."))
return(NA_character_)
} else {
if (length(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID) > 1) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned more than geocode. The first match was returned."))
}
return(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID)
}
}
}
}
# Function which takes an address data frame and outputs a data frame with the latitude and longitude coordinates for the permanent address
runGeocodeArcGIS <- function(df,address_col){
newdf <- geo(address = df[,address_col],method = "arcgis")
newdf$year <- str_replace_all(df$DOVISIT,pattern = "-.*",replacement = "")
return(newdf)
}
# Function which takes a data frame with lattitude/longitude coordinates and attaches information about the Census Block from the 2010 Census
getCensusBlocks <- function(df){
CensusBlock <- call_geolocator_latlon(lat = df$lat, lon = df$long,vintage = "Census2010_Current")
newdf <- data.frame("address" = df$address,lat = df$lat,long = df$long,CensusBlock = CensusBlock,year = df$year)
return(newdf)
}
# Function which takes the state, country, tract, and (partial) block numbers for an address and linnks the block to variables from the ACS survey
getCensusVars <- function(df){
geoID <- paste0(df$state,df$county,df$tract,str_sub(df$block,start = 1,end = 1))
Census <- get_acs(geography = "block group",state = df$state,county = df$county,variables = NewVars,year = min(max(as.numeric(df$year) + 2,2013),2019))
Census.long <- Census %>%
filter(GEOID == geoID) %>%
select(variable,estimate) %>%
pivot_wider(names_from = variable,values_from = estimate)
newdf <- cbind(df,Census.long) %>%
select(-`row_number()`)
return(newdf)
}
address2 <- address %>%
mutate(across(c(PERM_ADDRESS,LOCAL_ADDRESS),~str_remove_all(.x,pattern = ","))) %>% # Remove commas from address
mutate(across(c(PERM_ADDRESS,LOCAL_ADDRESS), ~ str_trim(.x,side = "both"))) %>% #Trim whitespace in addresses
unite("PERM_address_full",PERM_ADDRESS:PERM_ZIP,sep = ", ",remove = FALSE) %>% # Create column for one line permanent address
unite("Local_address_full",LOCAL_ADDRESS:LOCAL_ZIP,sep = ", ",remove = FALSE) # Same thing for local addresses
# Split address2 data frame into list
address.all.list <- address2 %>%
group_split(row_number())
numCores <- detectCores()
parallel::mclapply(address.all.list[1],FUN = runGeocodeArcGIS(address_col = "PERM_address_full"),mc.cores = numCores)
parallel::mclapply(address.all.list[1],FUN = runGeocodeArcGIS,address_col = "PERM_address_full",mc.cores = numCores)
# Read in the data and packages
library(tidycensus)
library(tidygeocoder)
library(tidyverse)
library(tigris)
library(parallel)
address <- read_delim("~/Projects/Geocoding/Data/address_dump_oracle_Oct2021.xls",
delim = "\t", escape_double = FALSE,
col_types = cols(...11 = col_skip()),
trim_ws = TRUE)
demo <- read_csv("~/Projects/Geocoding/Data/address_dump_oracle_demographics.csv")
# call_geolocator_laton comes from the tidygeocoder package, had to make changes to the url so it ran properly
call_geolocator_latlon <- function(lat, lon, benchmark, vintage) {
if(missing(benchmark)) {
benchmark<-"Public_AR_Current"
} else {
benchmark<-benchmark
}
if(missing(vintage)) {
vintage<-"Current_Current"
} else {
vintage<-vintage
}
# Build url
call_start <- "https://geocoding.geo.census.gov/geocoder/geographies/coordinates?"
url <- paste0("x=", lon,"&y=", lat)
benchmark0 <- paste0("&benchmark=", benchmark)
vintage0 <- paste0("&vintage=", vintage, "&format=json")
url_full <- paste0(call_start, url, benchmark0, vintage0)
#print(url_full)
# Check response
r <- httr::GET(url_full)
httr::stop_for_status(r)
response <- httr::content(r)
if (length(response$result$geographies$`Census Blocks`[[1]]$GEOID) == 0) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned no geocodes. An NA was returned."))
return(NA_character_)
} else {
#regex search for block group geography in response
response_block<-grep(response[["result"]][["geographies"]], pattern = ".Block.")
#check If a block group result is found or return NA
#If block group response is found check GEOID length and return either NA for missing data or the value
if(length(response_block) == 0){
return(NA_character_)
} else {
if (length(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID) == 0) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned no geocodes. An NA was returned."))
return(NA_character_)
} else {
if (length(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID) > 1) {
message(paste0("Lat/lon (", lat, ", ", lon,
") returned more than geocode. The first match was returned."))
}
return(response[["result"]][["geographies"]][[response_block]][[1]]$GEOID)
}
}
}
}
# Function which takes an address data frame and outputs a data frame with the latitude and longitude coordinates for the permanent address
runGeocodeArcGIS <- function(df,address_col){
newdf <- geo(address = df[,address_col],method = "arcgis")
newdf$year <- str_replace_all(df$DOVISIT,pattern = "-.*",replacement = "")
return(newdf)
}
# Function which takes a data frame with lattitude/longitude coordinates and attaches information about the Census Block from the 2010 Census
getCensusBlocks <- function(df){
CensusBlock <- call_geolocator_latlon(lat = df$lat, lon = df$long,vintage = "Census2010_Current")
newdf <- data.frame("address" = df$address,lat = df$lat,long = df$long,CensusBlock = CensusBlock,year = df$year)
return(newdf)
}
# Function which takes the state, country, tract, and (partial) block numbers for an address and linnks the block to variables from the ACS survey
getCensusVars <- function(df){
geoID <- paste0(df$state,df$county,df$tract,str_sub(df$block,start = 1,end = 1))
Census <- get_acs(geography = "block group",state = df$state,county = df$county,variables = NewVars,year = min(max(as.numeric(df$year) + 2,2013),2019))
Census.long <- Census %>%
filter(GEOID == geoID) %>%
select(variable,estimate) %>%
pivot_wider(names_from = variable,values_from = estimate)
newdf <- cbind(df,Census.long) %>%
select(-`row_number()`)
return(newdf)
}
address2 <- address %>%
mutate(across(c(PERM_ADDRESS,LOCAL_ADDRESS),~str_remove_all(.x,pattern = ","))) %>% # Remove commas from address
mutate(across(c(PERM_ADDRESS,LOCAL_ADDRESS), ~ str_trim(.x,side = "both"))) %>% #Trim whitespace in addresses
unite("PERM_address_full",PERM_ADDRESS:PERM_ZIP,sep = ", ",remove = FALSE) %>% # Create column for one line permanent address
unite("Local_address_full",LOCAL_ADDRESS:LOCAL_ZIP,sep = ", ",remove = FALSE) # Same thing for local addresses
# Split address2 data frame into list
address.all.list <- address2 %>%
group_split(row_number())
numCores <- detectCores()
parallel::mclapply(address.all.list[1],FUN = runGeocodeArcGIS,address_col = "PERM_address_full",mc.cores = numCores)
address_arcGIS <- bind_rows(address_arcGIS)
parallel::mclapply(address.all.list[1],FUN = runGeocodeArcGIS,address_col = "PERM_address_full",mc.cores = numCores)
df = address.all.list[[1]]
df
df[,address_col]
address_col = "PERM_address_full"
df[,address_col]
as.character(df[,address_col])
runGeocodeArcGIS <- function(df,address_col){
newdf <- geo(address = as.character(df[,address_col]),method = "arcgis")
newdf$year <- str_replace_all(df$DOVISIT,pattern = "-.*",replacement = "")
return(newdf)
}
parallel::mclapply(address.all.list[1],FUN = runGeocodeArcGIS,address_col = "PERM_address_full",mc.cores = numCores)
